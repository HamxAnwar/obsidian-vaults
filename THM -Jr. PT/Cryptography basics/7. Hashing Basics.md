- Imagine we download a file or get a file from someone in USB.
	- How do we know that this is the exact replica of the original file?
	- We can use hash comparison.
	- If the hash values of two files are identical, there is high certainity that the files are same.
- A hash function computes takes an input of an arbitrary size and returns a fix length output called a hash.
#### Hash Functions
- DIfferent from encryption
- No key
- Impossible to compute the input from the output
- A hash function takes input of any size and creates a summary or digest of that data.
	- Fixed size output.
	- Hard to predict the output from input and vice versa.
	- Good hashing algorithms are fast to compute output (input to output) and slow to reverse (output to input).
	- Slight change in the input data (even changing a single bit) changes the output significantly.
- **Example:**
	- Two files:
		- File 1 has alphabet: `T`
		- File 2 has alphabet: `U`
	- The letter T is `54` in hexadecimal, i.e., `01010100` in binary.
	- The letter U is `55` in hexadecimal, i.e., `01010101` in binary.
	- Applying various hashing algorithms
		- MD5 (Message-Digest Algorithm 5)
		- SHA1 (Secure Hash Algorithm 1)
		- SHA-256 (Secure Hash Algorithm 256)
		- ```
		shell-session
strategos@g5000 ~> cat file1.txt 
T⏎
strategos@g5000 ~> cat file2.txt 
U⏎   
strategos@g5000 ~> hexdump -C file1.txt 
00000000  54                                                |T|
00000001
strategos@g5000 ~> hexdump -C file2.txt 
00000000  55                                                |U|
00000001
strategos@g5000 ~> md5sum *.txt
b9ece18c950afbfa6b0fdbfa4ff731d3  file1.txt
4c614360da93c0a041b22e537de151eb  file2.txt
strategos@g5000 ~> sha1sum *.txt
c2c53d66948214258a26ca9ca845d7ac0c17f8e7  file1.txt
b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6  file2.txt
*strategos@g5000 ~> sha256sum *.txt*
e632b7095b0bf32c260fa4c539e9fd7b852d0de454e9be26f24d0d6f91d069d3  file1.txt
a25513c7e0f6eaa80a3337ee18081b9e2ed09e00af8531c8f7bb2542764027e7  file2.txt
		```
- The output of hash function are raw bytes, later encoded.
- Common encodings:
	- Hexadecimal output producing algorithms 
		- md5sum
		- sha1sum
		- sha256sum
		- sha512sum
	- Base64
**Importance of Hashing**
- Helps data integrity
- Ensures password confidentiality
- Hashing is also used to store passwords in PCs/servers such as /etc/shadow
- Hashing is also used to verify passwords while logging in to a server.
	- A server doesn't record our password but it hash value.
	- When we want to log in, it compares the hash value with the generated hash of the password we entered.
**Hash collision**
- Two different inputs give the same output.
	- Hash functions are designed to avoid collisions.
	- They are also designed to prevent attackers to cause collision.
- Since the number of inputs are practically unlimited while the outputs are limited, it creates a pigeonhole effect.
- As a numeric example, if a hash function produces a 4-bit hash value, we only have 16 different hash values.
	- The total number of possible hash values is
	$$
	2^{number\_of\_bits} = 2^4 = 16
	$$
	- The probability of a collision is relatively very high.
- A *pigeonhole effect* is when the number of items (pigeons) are greater than the number of containers (pigeonholes).
	- Some containers must hold more than one item.
- Collisions are unavoidable.
- However, a good hash function ensures that the probabity of collision is negligible.
- MD5 and SHA1 have been attacked and are now considered insecure due to the ability to engineer hash collisions.
#### Insecure Password Storage for Authentication
- Hashing doesn't implement in password managers.
- Storing passwords in plaintext is insecure.
	- Many people use same passwords for multiple accounts.
	- It is known to leak databases from various companies.
	- This leak while passwords are stored in plaintext could result in jeoperdize multiple account's safety and security.
- Three insecure practices:
	- Storing passwords in plaintext
	- Storing passwords using a deprecated encryption
	- Storing passwords using an insecure hashing algorithm
- **Data Breaches**
	- The `rockyou.txt` is a data breach containing about 14 million passwords.
		- From a company, RockYou, that developed on social media applications and widgets.
	- Adobe’s notable data breach included:
		- Instead of using a secure hashing function to store the hash values of the passwords, the company used a deprecated encryption format.
		- Password hints were also stored in plain text, sometimes containing the password itself.
		- The plaintext password could be retrieved relatively quickly.
	- LinkedIn also suffered a data breach in 2012.
		- LinkedIn used an insecure hashing algorithm, the SHA-1, to store user passwords.
		- No password salting was used.
		- **Password salting** refers to adding a **salt**, i.e., a random value, to the password before it is hashed.
#### Using hashing for Secure Password Storage
- Instead of storing a password, we store hash for it using a secure hashing function.
- It is secure because an attacker would have to crack each password to find out what the password was.
- But what if one password is being used by multiple users?
	- It will store same hash for the password, since it gives out same hash for same passwords.
	- Cracking on hash could reveal password to not only multiple accounts but also multiple users.
	- Someone can also make a Rainbow Table to break hashes.
- **Rainbow Table**
	- A lookup table of hashes to plaintexts.
	- A rainbow table trades the time to crack a hash for hard disk space, but it takes time to create.
	- **Example**

| Hash                             | Password      |
| -------------------------------- | ------------- |
| 02c75fb22c75b23dc963c7eb91a062cc | zxcvbnm       |
| b0baee9d279d34fa1dfd71aadb908c3f | 11111         |
| c44a471bd78cc6c2fea32b9fe028d30a | asdfghjkl     |
| d0199f51d2728db6011945145a1b607a | basketball    |
| dcddb75469b4b4875094e14561e573d8 | 000000        |
| e10adc3949ba59abbe56e057f20f883e | 123456        |
| e19d5cd5af0378da05f63f891c7467af | abcd1234      |
| e99a18c428cb38d5f260853678922e03 | abc123        |
| fcea920f7412b5da7be0cf42b8c93759 | 1234567       |
| 4c5923b6a6fac7b7355f53bfe2b8f8c1 | inS3CyourP4$$ |

- Websites that use internally massive rainbow tables to provide fast password cracking for hashes without salts:
	- [Crackstation](https://crackstation.net/)
	- [Hashes.com](https://hashes.com/en/decrypt/hash)
- **Protecting Against Rainbow Tables**
	- Add salt to passwords.
		- **Salt**: A randomly generated value stored in the database and should be unique to each user.
	- Added to the start or end of the password before it is hashed.
	- Every user would have a different password due to different salt.
	- Hash functions with automatic salting:
		- Bcrypt
		- Scrypt
	- Salt don't need to be kept private.
- **Example of Securely Storing Password**
	1. We select a secure hashing function, such as Argon2, Scrypt, Bcrypt, or PBKDF2.
	2. We add a unique salt to the password, such as `Y4UV*^(=go_!`
	3. Concatenate the password with the unique salt. For example, if the password is `AL4RMc10k`, the result string would be `AL4RMc10kY4UV*^(=go_!`
	4. Calculate the hash value of the combined password and salt. In this example, using the chosen algorithm, you need to calculate the hash value of `AL4RMc10kY4UV*^(=go_!`.
	5. Store the hash value and the unique salt used (`Y4UV*^(=go_!`).
- **Using Encryption to Store Passwords**
	- Why don't we encrypt passwords for storage?
	- The reason is a key is always required.
	- If someone gets that key, all the passwords are easily decryptable.
#### Recognising Password Hashes
- If we start with a hash:
	- How can we recognise its type?
	- How can we crack it?
	- How can we recover the original password?
- Automated hash recognition tools:
	- [hashID](https://pypi.org/project/hashID/)
	- Not reliable for hashes without prefix.
	- If we find a hash in a web application database, likely the hash is MD5 instead of NTLM (NT LAN Manager).
	- Automated tools often get these hashes mixed up.
- **Linux Passwords**
	- On linux, password hashes are stored in `/etc/shadow`.
	- Previously they were stored in `/etc/passwd` which was readable by everyone.
	- `Shadow` file contains nine fields separated by ( : ).
	- The first two fields are:
		1. Login name
		2. Encrypted password (has four components)
			1. Prefix (algorithm ID)
			2. Options (parameters)
			3. salt
			4. hash
	- Format: `$prefix$options$salt$hash`
	- Prefix makes it easier to recognise Unix and Linux-style passwords, specifying the hashing algorithm.
	- The following table lists unix-style password prefixes in decreasing length.

| Prefix                         | Algorithm                                                                                                                                                                                        |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `$y$`                          | yescrypt is a scalable hashing scheme and is the default and recommended choice in new systems                                                                                                   |
| `$gy$`                         | gost-yescrypt uses the GOST R 34.11-2012 hash function and the yescrypt hashing method                                                                                                           |
| `$7$`                          | scrypt is a password-based key derivation function                                                                                                                                               |
| `$2b$`, `$2y$`, `$2a$`, `$2x$` | bcrypt is a hash based on the Blowfish block cipher originally developed for OpenBSD but supported on a recent version of FreeBSD, NetBSD, Solaris 10 and newer, and several Linux distributions |
| `$6$`                          | sha512crypt is a hash based on SHA-2 with 512-bit output originally developed for GNU libc and commonly used on (older) Linux systems                                                            |
| `$md5`                         | SunMD5 is a hash based on the MD5 algorithm originally developed for Solaris                                                                                                                     |
| `$1$`                          | md5crypt is a hash based on the MD5 algorithm originally developed for FreeBSD                                                                                                                   |
- **Modern Linux Example**
	- Consider the linux shadow file:
	- `strategos:$y$j9T$76UzfgEM5PnymhQ7TlJey1$/OOSg64dhfF.TigVPdzqiFang6uZA4QA1pzzegKdVm4:19965:0:99999:7:::`
	- **Username**: strategos
	- **Hashing algorithm**:
		- **Prefix**: y = yescrypt
		- **Options**: j9T
		- **Salt**: 76UzfgEM5PnymhQ7TlJey1
		- **Hash**: /OOSg64dhfF.TigVPdzqiFang6uZA4QA1pzzegKdVm4
- **MS Windows Passwords**
	- MS windows passwords are hashed in NTLM (a variant of MD4).
	- Identical to MD4 and MD5 hashes.
	- Password hashes are stored in SAM(Security Accounts Manager).
	- Normal users cannot dump the hashes, but tools exist to circumvent MS Windows security:
		- `Mimikatz`
		- Hashes found are NT and LM hashes.
	- A great place to find more hash formats and password prefixes is the [Hashcat Example Hashes](https://hashcat.net/wiki/doku.php?id=example_hashes) page.
	- For other hash types:
		- Check the length and encoding
		- Conduct some research into the application that generated them.
#### Password Cracking
- Rainbow tables to crack hashes that don't use salt.
- What if there is salt involved?
- We can't decrypt hashes since they are not encrypted.
- We need to crack the hashes by hashing many different inputs such as `rockyou.txt`.
	- Potentially adding salt and then comparing to target hash.
	- Once it matches, we can know what the password was.
- Tools to do it:
	- [[Hashcat]]
	- John the Ripper
- **Cracking with GPUs**
	- Modern GPUs are good at some mathematical calculations used in hashing functions.
	- We can use graphic cards to crack many hash types quickly.
	- Some hashing algorithms, such as Bcrypt, are designed so that hashing on a GPU provides no speed enhancement.
		- Helps resist cracking.
- **Cracking on VMs**
	- Try to use hosts instead of VMs since it will effect the speeds and host usage will always be faster than VM for cracking hashes.
#### Hashing for Integrity Checking
- In the above and the hashcat cracking, we focused on password storage.
- Now we discuss how can we use hashing to check integrity of files.
- **Integrity checking**
	- Same files always give same hashes.
	- Changing a single bit would change the hash completely.
- **Keyed-Hash Message Authentication Code (HMACs)**
	- A type of Message Authentication Code (MAC), using cryptographic hashing functions in combination with a secret key to verify the authenticity and integrity of data.
	- An HMAC can be used to ensure that the person who created the HMAC is who they say they are, i.e., authenticity is confirmed.
	- It also proves that the message hasn’t been modified or corrupted, i.e., integrity is maintained.
	- The following steps give you a fair idea of how HMAC works.
		1. The secret key is padded to the block size of the hash function.
		2. The padded key is XORed with a constant (usually a block of zeros or ones).
		3. The message is hashed using the hash function with the XORed key.
		4. The result from Step 3 is then hashed again with the same hash function but using the padded key XORed with another constant.
		5. The final output is the HMAC value, typically a fixed-size string.
	![[Pasted image 20250727131756.png]]
	- Technically, the expression to calculate HMAC is as follows:
		$$HMAC(K,M) = H((K⊕opad)||H((K⊕ipad)||M))$$
		Where;
			M: Message
			K: Key